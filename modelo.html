<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>15-Story Building – Extended Scene</title>
  <style>
    /* Estilos globales */
    body {
      margin: 0;
      overflow: hidden;
      background: #ffffff;
      font-family: 'Segoe UI', sans-serif;
    }
    /* Contenedor del visualizador (900 x 550 px) */
    #viewer {
      width: 900px;
      height: 550px;
      position: relative;
      margin: 0 auto;
      background: #eaeaea;
      border-radius: 15px;
      overflow: hidden;
    }
    /* Instrucción central: “Drag to rotate, mouse wheel to zoom” */
    #instruction {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(25, 25, 25, 0.8);
      color: #fff;
      padding: 20px 30px;
      border-radius: 10px;
      text-align: center;
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.5s ease;
      z-index: 10;
    }
    #instruction p {
      margin: 0;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <!-- Contenedor principal para el renderizado -->
  <div id="viewer">
    <!-- Burbuja de instrucciones (en inglés) -->
    <div id="instruction">
      <p>Drag to rotate, mouse wheel to zoom</p>
    </div>
  </div>

  <!-- Carga de Three.js y OrbitControls con defer para no bloquear el render -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js" defer></script>
  
  <script>
    // Esperamos a que se cargue el DOM
    window.addEventListener('DOMContentLoaded', function() {
      let scene, camera, renderer, controls, building;
      
      const materials = {
        glass: new THREE.MeshPhysicalMaterial({
          color: 0xdddddd,
          metalness: 0.7,
          roughness: 0.1,
          transparent: true,
          opacity: 0.8,
          envMapIntensity: 1.2
        }),
        metal: new THREE.MeshStandardMaterial({
          color: 0xaaaaaa,
          metalness: 0.9,
          roughness: 0.2
        }),
        concrete: new THREE.MeshStandardMaterial({
          color: 0xcccccc,
          roughness: 0.6
        })
      };
      
      init();
      animate();
      
      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xb0b0b0);
      
        // Usar el contenedor #viewer para el render
        const viewer = document.getElementById('viewer');
        camera = new THREE.PerspectiveCamera(45, viewer.clientWidth / viewer.clientHeight, 1, 1000);
      
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(viewer.clientWidth, viewer.clientHeight);
        renderer.shadowMap.enabled = true;
        viewer.appendChild(renderer.domElement);
      
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 50;
        controls.maxDistance = 200;
        controls.maxPolarAngle = Math.PI / 2;
        // Al iniciar la interacción se quita la instrucción
        controls.addEventListener('start', removeInstruction);
      
        setupLighting();
        createBuilding();
        createEnvironment();
      
        camera.position.set(40, 60, 80);
        controls.update();
      
        window.addEventListener('resize', onWindowResize);
      }
      
      function setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
      
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
      }
      
      // ===================================================
      // Edificio principal: 15 pisos de vidrio con esquinas redondeadas y columnas
      // ===================================================
      function createBuilding() {
        building = new THREE.Group();
        const totalHeight = 60; // 15 floors x 4 units (de -30 a 30)
        const floors = 15;
        const floorHeight = totalHeight / floors; // 4 unidades por piso
        const baseWidth = 20;
        for (let i = 0; i < floors; i++) {
          const width = baseWidth * (1 - (i / floors) * 0.1);
          const geometry = createRoundedFloor(width, floorHeight);
          const floorMesh = new THREE.Mesh(geometry, materials.glass);
          floorMesh.castShadow = true;
          floorMesh.receiveShadow = true;
          floorMesh.position.y = i * floorHeight - totalHeight / 2;
          // Agregar ventanas a este piso:
          createWindows(floorMesh, width, floorHeight);
          building.add(floorMesh);
        }
      
        // Columnas continuas (de piso a techo)
        const columnMaterial = new THREE.MeshStandardMaterial({
          color: 0xc0c0c0,
          roughness: 0.4
        });
        const columnHeight = totalHeight;
        const columnGeometry = new THREE.CylinderGeometry(0.3, 0.3, columnHeight, 8);
        for (let j = 0; j < 8; j++) {
          let angle = (j * Math.PI * 2) / 8;
          let radius = baseWidth / 2 - 1;
          let x = radius * Math.cos(angle);
          let z = radius * Math.sin(angle);
          const column = new THREE.Mesh(columnGeometry, columnMaterial);
          column.position.set(x, 0, z);
          column.castShadow = true;
          column.receiveShadow = true;
          building.add(column);
        }
      
        createEntrance(totalHeight);
        createRoof();
        scene.add(building);
      }
      
      // Crea un piso con esquinas redondeadas mediante extrusión
      function createRoundedFloor(width, floorHeight) {
        const radius = width * 0.1;
        const half = width / 2;
        const shape = new THREE.Shape();
        shape.moveTo(-half + radius, -half);
        shape.lineTo(half - radius, -half);
        shape.quadraticCurveTo(half, -half, half, -half + radius);
        shape.lineTo(half, half - radius);
        shape.quadraticCurveTo(half, half, half - radius, half);
        shape.lineTo(-half + radius, half);
        shape.quadraticCurveTo(-half, half, -half, half - radius);
        shape.lineTo(-half, -half + radius);
        shape.quadraticCurveTo(-half, -half, -half + radius, -half);
      
        const extrudeSettings = {
          depth: floorHeight,
          bevelEnabled: false,
          steps: 1
        };
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geometry.rotateX(-Math.PI / 2);
        return geometry;
      }
      
      // Crea ventanas para cada piso
      function createWindows(floorMesh, width, height) {
        floorMesh.userData.floorHeight = height;
        const windowGrid = new THREE.Group();
        const windowWidth = 1.2;
        const windowHeight = height * 0.7;
        const windowSpacing = 0.4;
      
        for (let x = -width / 2 + 1.5; x < width / 2 - 1.5; x += windowWidth + windowSpacing) {
          for (let z = -width / 2 + 1.5; z < width / 2 - 1.5; z += windowWidth + windowSpacing) {
            const windowGeom = new THREE.BoxGeometry(windowWidth, windowHeight, 0.1);
            const windowFrame = new THREE.Mesh(windowGeom, materials.metal);
            windowFrame.name = "windowFrame";
            windowFrame.userData.windowWidth = windowWidth;
            windowFrame.userData.originalWindowHeight = windowHeight;
            windowFrame.userData.originalGeometry = windowGeom.clone();
            windowFrame.position.set(x, -height / 4, z);
            windowFrame.castShadow = true;
            windowGrid.add(windowFrame);
          }
        }
        floorMesh.add(windowGrid);
      }
      
      function createEntrance(totalHeight) {
        const entranceGroup = new THREE.Group();
        const entranceWidth = 8;
        const doorGeometry = new THREE.BoxGeometry(2, 4, 0.2);
        for (let i = -1; i <= 1; i += 2) {
          const door = new THREE.Mesh(doorGeometry, materials.metal);
          door.position.set(i * 1.5, -totalHeight / 2 + 2, entranceWidth / 2);
          entranceGroup.add(door);
        }
        const canopy = new THREE.Mesh(
          new THREE.BoxGeometry(entranceWidth + 2, 1, 4),
          materials.concrete
        );
        canopy.position.set(0, -totalHeight / 2 + 0.5, entranceWidth / 2 - 2);
        entranceGroup.add(canopy);
        for (let i = 0; i < 8; i++) {
          const person = createPerson();
          person.position.set(
            (Math.random() - 0.5) * entranceWidth,
            -totalHeight / 2 + 0.3,
            entranceWidth / 2 + Math.random() * 2
          );
          entranceGroup.add(person);
        }
        building.add(entranceGroup);
      }
      
      function createRoof() {
        const roofGroup = new THREE.Group();
        // Techo principal
        const roofGeometry = new THREE.BoxGeometry(12, 2, 12);
        const roof = new THREE.Mesh(roofGeometry, materials.concrete);
        roof.position.y = 30;
        roofGroup.add(roof);
        // AC Unit
        const acUnit = new THREE.Mesh(
          new THREE.BoxGeometry(2, 1, 2),
          materials.metal
        );
        acUnit.position.set(3, 31.5, 3);
        roofGroup.add(acUnit);
        // Antena con detalle escalonado
        const antennaGroup = new THREE.Group();
        const baseGeometry = new THREE.BoxGeometry(8, 1, 8);
        const baseBlock = new THREE.Mesh(baseGeometry, materials.metal);
        baseBlock.position.y = 31;
        antennaGroup.add(baseBlock);
        const step1Geometry = new THREE.BoxGeometry(6, 1, 6);
        const step1 = new THREE.Mesh(step1Geometry, materials.metal);
        step1.position.y = 32;
        antennaGroup.add(step1);
        const step2Geometry = new THREE.BoxGeometry(4, 1, 4);
        const step2 = new THREE.Mesh(step2Geometry, materials.metal);
        step2.position.y = 33;
        antennaGroup.add(step2);
        const coneGeometry = new THREE.ConeGeometry(1, 3, 8);
        const cone = new THREE.Mesh(coneGeometry, materials.metal);
        cone.position.y = 34.5;
        antennaGroup.add(cone);
        roofGroup.add(antennaGroup);
        building.add(roofGroup);
      }
      
      function createPerson() {
        const person = new THREE.Group();
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.15, 0.8, 8),
          bodyMaterial
        );
        body.position.y = 0.4;
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.18, 8, 8),
          bodyMaterial
        );
        head.position.y = 0.9;
        person.add(body);
        person.add(head);
        person.castShadow = true;
        return person;
      }
      
      function createCar() {
        const car = new THREE.Group();
        const bodyGeometry = new THREE.BoxGeometry(2.5, 0.8, 1.2);
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        body.receiveShadow = true;
        body.position.y = 0.5;
        car.add(body);
        const wheelGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.3, 12);
        const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        for (let i = -1; i <= 1; i += 2) {
          for (let j = -0.6; j <= 0.6; j += 1.2) {
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.rotation.z = Math.PI / 2;
            wheel.position.set(i * 0.9, 0.25, j);
            wheel.castShadow = true;
            wheel.receiveShadow = true;
            car.add(wheel);
          }
        }
        return car;
      }
      
      function createEnvironment() {
        const ground = new THREE.Mesh(
          new THREE.BoxGeometry(200, 10, 200),
          new THREE.MeshStandardMaterial({ color: 0x808080 })
        );
        ground.position.y = -35;
        ground.receiveShadow = true;
        scene.add(ground);
      
        const roadWidth = 12;
        const sidewalkWidth = 3;
        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
      
        const horizontalRoadZ = [-60, -20, 20, 60];
        horizontalRoadZ.forEach((z) => {
          const road = new THREE.Mesh(
            new THREE.PlaneGeometry(200, roadWidth),
            roadMaterial
          );
          road.rotation.x = -Math.PI / 2;
          road.position.set(0, -29.9, z);
          road.receiveShadow = true;
          scene.add(road);
          const sidewalkNorth = new THREE.Mesh(
            new THREE.PlaneGeometry(200, sidewalkWidth),
            new THREE.MeshStandardMaterial({ color: 0xa0a0a0 })
          );
          sidewalkNorth.rotation.x = -Math.PI / 2;
          sidewalkNorth.position.set(0, -29.8, z + roadWidth / 2 + sidewalkWidth / 2);
          sidewalkNorth.receiveShadow = true;
          scene.add(sidewalkNorth);
          const sidewalkSouth = sidewalkNorth.clone();
          sidewalkSouth.position.set(0, -29.8, z - roadWidth / 2 - sidewalkWidth / 2);
          scene.add(sidewalkSouth);
          for (let i = -100; i <= 100; i += 25) {
            const tree1 = createTree();
            tree1.position.set(i, -29.8, z + roadWidth / 2 + sidewalkWidth + 1);
            scene.add(tree1);
            const tree2 = createTree();
            tree2.position.set(i, -29.8, z - roadWidth / 2 - sidewalkWidth - 1);
            scene.add(tree2);
          }
        });
      
        const verticalRoadX = [-60, -20, 20, 60];
        verticalRoadX.forEach((x) => {
          const road = new THREE.Mesh(
            new THREE.PlaneGeometry(200, roadWidth),
            roadMaterial
          );
          road.rotation.x = -Math.PI / 2;
          road.rotation.z = Math.PI / 2;
          road.position.set(x, -29.9, 0);
          road.receiveShadow = true;
          scene.add(road);
          const sidewalkEast = new THREE.Mesh(
            new THREE.PlaneGeometry(200, sidewalkWidth),
            new THREE.MeshStandardMaterial({ color: 0xa0a0a0 })
          );
          sidewalkEast.rotation.x = -Math.PI / 2;
          sidewalkEast.rotation.z = Math.PI / 2;
          sidewalkEast.position.set(x + roadWidth / 2 + sidewalkWidth / 2, -29.8, 0);
          sidewalkEast.receiveShadow = true;
          scene.add(sidewalkEast);
          const sidewalkWest = sidewalkEast.clone();
          sidewalkWest.position.set(x - roadWidth / 2 - sidewalkWidth / 2, -29.8, 0);
          scene.add(sidewalkWest);
          for (let i = -100; i <= 100; i += 25) {
            const tree1 = createTree();
            tree1.position.set(x + roadWidth / 2 + sidewalkWidth + 1, -29.8, i);
            scene.add(tree1);
            const tree2 = createTree();
            tree2.position.set(x - roadWidth / 2 - sidewalkWidth - 1, -29.8, i);
            scene.add(tree2);
          }
        });
      
        for (let i = 0; i < 5; i++) {
          const car = createCar();
          const zBase = horizontalRoadZ[Math.floor(Math.random() * horizontalRoadZ.length)];
          const zPos = zBase + (Math.random() - 0.5) * (roadWidth - 2);
          const xPos = -90 + Math.random() * 180;
          car.position.set(xPos, -29.9, zPos);
          scene.add(car);
        }
      
        for (let i = 0; i < 15; i++) {
          const person = createPerson();
          const zBase = horizontalRoadZ[Math.floor(Math.random() * horizontalRoadZ.length)];
          const side = Math.random() > 0.5 ? 1 : -1;
          person.position.set(
            -90 + Math.random() * 180,
            -29.8,
            zBase + side * (roadWidth / 2 + sidewalkWidth + Math.random())
          );
          scene.add(person);
        }
      
        const verticalRoadXs = verticalRoadX;
        const horizontalRoadZs = horizontalRoadZ;
        function isNearRoad(x, z) {
          for (let r of verticalRoadXs) {
            if (Math.abs(x - r) < roadWidth / 2 + sidewalkWidth + 2) return true;
          }
          for (let r of horizontalRoadZs) {
            if (Math.abs(z - r) < roadWidth / 2 + sidewalkWidth + 2) return true;
          }
          return false;
        }
        let count = 0;
        while (count < 20) {
          const x = -90 + Math.random() * 180;
          const z = -90 + Math.random() * 180;
          if (isNearRoad(x, z)) continue;
          const house = createSmallBuilding(x, z);
          scene.add(house);
          count++;
        }
      
        for (let i = 0; i < 3; i++) {
          const mediumBuilding = createMediumBuilding(-30 + i * 30, 30 + Math.random() * 10);
          scene.add(mediumBuilding);
        }
      
        const skyGeo = new THREE.SphereGeometry(500, 32, 15);
        const skyMat = new THREE.MeshBasicMaterial({
          color: 0xb0c4de,
          side: THREE.BackSide
        });
        const skyDome = new THREE.Mesh(skyGeo, skyMat);
        scene.add(skyDome);
      }
      
      function createSmallBuilding(x, z) {
        const floors = Math.random() < 0.5 ? 1 : 2;
        const floorHeight = 4;
        const height = floors * floorHeight;
        const size = 4;
        const buildingGeometry = new THREE.BoxGeometry(size, height, size);
        const buildingMaterial = new THREE.MeshStandardMaterial({
          color: 0xd3d3d3,
          roughness: 0.8
        });
        const house = new THREE.Mesh(buildingGeometry, buildingMaterial);
        house.castShadow = true;
        house.receiveShadow = true;
        house.position.set(x, -30 + height / 2, z);
        return house;
      }
      
      function createMediumBuilding(x, z) {
        const floors = 10;
        const floorHeight = 4;
        const totalHeight = floors * floorHeight;
        const width = 12;
        const depth = 12;
        const buildingGroup = new THREE.Group();
        for (let i = 0; i < floors; i++) {
          const floorGeometry = new THREE.BoxGeometry(width, floorHeight, depth);
          const floorMesh = new THREE.Mesh(floorGeometry, materials.concrete);
          floorMesh.castShadow = true;
          floorMesh.receiveShadow = true;
          floorMesh.position.y = i * floorHeight;
          buildingGroup.add(floorMesh);
        }
        buildingGroup.position.set(x, -30, z);
        return buildingGroup;
      }
      
      function createTree() {
        const tree = new THREE.Group();
        const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 1;
        trunk.castShadow = true;
        trunk.receiveShadow = true;
        tree.add(trunk);
      
        const crownGeometry = new THREE.ConeGeometry(1, 3, 8);
        const crownMaterial = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
        const crown = new THREE.Mesh(crownGeometry, crownMaterial);
        crown.position.y = 3;
        crown.castShadow = true;
        crown.receiveShadow = true;
        tree.add(crown);
        return tree;
      }
      
      // Función para quitar la instrucción al comenzar a interactuar
      function removeInstruction() {
        const instruction = document.getElementById('instruction');
        if (instruction) {
          instruction.style.opacity = 0;
          setTimeout(() => {
            instruction.style.display = 'none';
          }, 500);
        }
      }
      
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      
      function onWindowResize() {
        const viewer = document.getElementById('viewer');
        camera.aspect = viewer.clientWidth / viewer.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(viewer.clientWidth, viewer.clientHeight);
      }
    });
  </script>
</body>
</html>
